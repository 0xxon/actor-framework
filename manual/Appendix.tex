\section{Appendix}

\subsection{Class \texttt{option}}
\label{Appendix::Option}

Defined in header \lstinline^"cppa/option.hpp"^.

\begin{lstlisting}
template<typename T>
class option;
\end{lstlisting}

Represents an optional value.

{\small
\begin{tabular*}{\textwidth}{m{0.5\linewidth}m{0.45\linewidth}}
  \multicolumn{2}{l}{\large{\textbf{Member types}}\vspace{3pt}} \\
  \hline
  \textbf{Member type} & \textbf{Definition} \\
  \hline
  \lstinline^type^ & \lstinline^T^ \\
  \hline
  \\
  \multicolumn{2}{l}{\large{\textbf{Member Functions}}\vspace{3pt}} \\
  \hline
  \lstinline^option()^ & Constructs an empty option \\
  \hline
  \lstinline^option(T value)^ & Initializes \lstinline^this^ with \lstinline^value^ \\
  \hline
  \lstinline^option(const option&)^\newline\lstinline^option(option&&)^ & Copy/move construction \\
  \hline
  \lstinline^option& operator=(const option&)^\newline\lstinline^option& operator=(option&&)^ & Copy/move assignment \\
  \hline
  \\
  \multicolumn{2}{l}{\textbf{Observers}\vspace{3pt}} \\
  \hline
  \lstinline^bool valid()^\newline\lstinline^explicit operator bool()^ & Returns \lstinline^true^ if \lstinline^this^ has a value \\
  \hline
  \lstinline^bool empty()^\newline\lstinline^bool operator!()^ & Returns \lstinline^true^ if \lstinline^this^ does \textbf{not} has a value \\
  \hline
  \lstinline^const T& get()^\newline\lstinline^const T& operator*()^ & Access stored value \\
  \hline
  \lstinline^const T& get_or_else(const T& x)^ & Returns \lstinline^get()^ if valid, \lstinline^x^ otherwise  \\
  \hline
  \\
  \multicolumn{2}{l}{\textbf{Modifiers}\vspace{3pt}} \\
  \hline
  \lstinline^T& get()^\newline\lstinline^T& operator*()^ & Access stored value \\
  \hline
\end{tabular*}
}

\clearpage
\subsection{Using \texttt{aout} -- A Concurrency-safe Wrapper for \texttt{cout}}

When using \lstinline^cout^ from multiple actors, output often appears interleaved.
Moreover, using \lstinline^cout^ from multiple actors -- and thus from multiple threads -- in parallel should be avoided regardless, since the standard does not guarantee a thread-safe implementation.

By replacing \texttt{std::cout} with \texttt{cppa::aout}, actors can achieve a concurrency-safe text output.
The header \lstinline^cppa/cppa.hpp^ also defines overloads for \texttt{std::endl} and \texttt{std::flush} for \lstinline^aout^, but does not support the full range of ostream operations (yet).
Each write operation to \texttt{aout} sends a message to a `hidden' actor (keep in mind, sending messages from actor constructors is not safe).
This actor only prints lines, unless output is forced using \lstinline^flush^.
The example below illustrates printing of lines of text from multiple actors (in random order).

\begin{lstlisting}
#include <chrono>
#include <cstdlib>
#include <iostream>
#include "cppa/cppa.hpp"

using namespace cppa;
using std::endl;

int main() {
    std::srand(std::time(0));
    for (int i = 1; i <= 50; ++i) {
        spawn<blocking_api>([i](blocking_actor* self) {
          aout(self) << "Hi there! This is actor nr. "
                     << i << "!" << endl;
          std::chrono::milliseconds tout{std::rand() % 1000};
          self->delayed_send(self, tout, atom("done"));
          self->receive(others() >> [i, self] {
              aout(self) << "Actor nr. "
                         << i << " says goodbye!" << endl;
          });
        });
    }
    // wait until all other actors we've spawned are done
    await_all_actors_done();
    // done
    shutdown();
    return 0;
}
\end{lstlisting}

\clearpage
\subsection{Migration Guides}

The guides in this section document all possibly breaking changes in the library for that last versions of \lib.

\subsubsection{0.8 $\Rightarrow$ 0.9}

\paragraph{\lstinline^self^ has been removed}

~

This is the biggest library change since the initial release.
The major problem with this keyword-like identifier is that it must have a single type as it's implemented as a thread-local variable.
Since there are so many different kinds of actors (event-based or blocking, untyped or typed), \lstinline^self^ needs to perform type erasure at some point, rendering it ultimately useless.
Instead of a thread-local pointer, you can now use the first argument in functor-based actors to "catch" the self pointer with proper type information.

\paragraph{\lstinline^actor_ptr^ has been replaced}

~

\lib now distinguishes between handles to actors, i.e., \lstinline^typed_actor<...>^ or simply \lstinline^actor^, and \emph{addresses} of actors, i.e., \lstinline^actor_addr^. The reason for this change is that each actor has a logical, (network-wide) unique address, which is used by the networking layer of \lib. Furthermore, for monitoring or linking, the address is all you need. However, the address is not sufficient for sending messages, because it doesn't have any type information. The function \lstinline^last_sender()^ now returns the \emph{address} of the sender.
This means that previously valid code such as \lstinline^send(last_sender(), ...)^ will cause a compiler error.
However, the recommended way of replying to messages is to return the result from the message handler.

\paragraph{The API for typed actors is now similar to the API for untyped actors}

~

The APIs of typed and untyped actors have been harmonized.
Typed actors can now be published in the network and also use all operations untyped actors can.
