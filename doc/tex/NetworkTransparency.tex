\section{Middleman}
\label{middleman}

The middleman is the main component of the I/O module and enables distribution.
It transparently manages proxy actor instances representing remote actors,
maintains connections to other nodes, and takes care of serialization and
deserialization of messages. Applications install a middleman by loading
\lstinline^caf::io::middleman^ as module~\see{system-config}. Users can include
\lstinline^"caf/io/all.hpp"^ to get access to all public classes of the I/O
module.

\subsection{Class \texttt{middleman}}

\begin{center}
\begin{tabular}{ll}
  \textbf{Remoting} & ~ \\
  \hline
  \lstinline^expected<uint16> open(uri)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<uint16> open(uint16, const char*, bool)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<uint16> publish(T, uri)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<uint16> publish(T, uint16, const char*, bool)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<void> unpublish(T x, uint16)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<node_id> connect(uri)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<node_id> connect(string host, uint16_t port)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<T> remote_actor<T = actor>(uri)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<T> remote_actor<T = actor>(string, uint16)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<T> spawn_broker(F fun, ...)^ & See~\sref{broker}. \\
  \hline
  \lstinline^expected<T> spawn_client(F, string, uint16, ...)^ & See~\sref{broker}. \\
  \hline
  \lstinline^expected<T> spawn_server(F, uint16, ...)^ & See~\sref{broker}. \\
  \hline
\end{tabular}
\end{center}

\subsection{Publishing and Connecting}
\label{remoting}

The member function \lstinline^publish^ binds an actor to a given port, thereby
allowing other nodes to access it over the network.

\begin{lstlisting}
template <class T>
expected<uint16_t> middleman::publish(T whom, uri where);

template <class T>
expected<uint16_t> middleman::publish(T whom, uint16_t port = 0,
                                      const char* host = nullptr,
                                      bool reuse = false);
\end{lstlisting}

The first argument is a handle of type \lstinline^actor^ or
\lstinline^typed_actor<...>^. The second argument is an URI encoding which
hostname we wish to bind to (pass \lstinline^0.0.0.0^ to accept all incoming
connections), which port we wish to open (pass 0 to have the OS choose one),
and optional flags. The URI must use the scheme \lstinline^tcp^,
e.g., \lstinline^tcp://0.0.0.0^.

Currently, the middleman only checks for \lstinline^reuse-address=true^ with
the same semantics as the BSD socket flag \lstinline^SO_REUSEADDR^. For
example, with \lstinline^reuse_addr = false^, binding two sockets to 0.0.0.0:42
and 10.0.0.1:42 will fail with \texttt{EADDRINUSE} since 0.0.0.0 includes
10.0.0.1. With \lstinline^reuse_addr=true^, binding would succeed because
10.0.0.1 and 0.0.0.0 are not literally equal addresses.

The member function returns the bound port on success. Otherwise, an
\lstinline^error^ \see{error} is returned.

The second function overload allows users to pass individual components to the
middleman rather than wrapping the node information into an URI. All but the
first argument have defaults. Calling \lstinline^publish(self)^ has the same
effect as calling the function with the URI \lstinline^tcp://0.0.0.0^.

\begin{lstlisting}
template <class T>
expected<uint16_t> middleman::unpublish(T x, uint16_t port = 0);
\end{lstlisting}

The member function \lstinline^unpublish^ allows actors to close a port
manually. This is performed automatically if the published actor terminates.
Passing 0 as second argument closes all ports an actor is published to,
otherwise only one specific port is closed.

The function returns an \lstinline^error^ \see{error} if the actor was not
bound to given port.

\clearpage
\begin{lstlisting}
template<class T = actor>
expected<T> middleman::remote_actor(uri node);
\end{lstlisting}

After a server has published an actor with \lstinline^publish^, clients can
connect to the published actor by calling \lstinline^remote_actor^:

\begin{lstlisting}
// On node A (a.node).
auto ping = spawn(ping);
system.middleman().publish(ping, 4242);

// On some other node.
auto node = uri::from_string("tcp://a.node:4242");
assert(node);
auto ping = system.middleman().remote_actor(*node);
if (!ping) {
  cerr << "unable to connect to node A: "
       << system.render(ping.error()) << std::endl;
} else {
  self->send(*ping, ping_atom::value);
}
\end{lstlisting}

There is no difference between server and client after the connection phase.
Remote actors use the same handle types as local actors and are thus fully
transparent.

The function pair \lstinline^open^ and \lstinline^connect^ allows users to
connect CAF instances without remote actor setup. The function
\lstinline^connect^ returns a \lstinline^node_id^ that can be used for remote
spawning (see~\sref{remote-spawn}).

\subsection{Free Functions}
\label{free-remoting-functions}

The following free functions in the namespace \lstinline^caf::io^ avoid calling
the middleman directly. This enables users to easily switch between
communication backends as long as the interfaces have the same signatures. For
example, the (experimental) OpenSSL binding of CAF implements the same
functions in the namespace \lstinline^caf::openssl^ to easily switch between
encrypted and unencrypted communication.

\begin{center}
\begin{tabular}{ll}
  \hline
  \lstinline^expected<uint16> open(actor_system&, uint16, const char*, bool)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<uint16> publish(T, uint16, const char*, bool)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<void> unpublish(T x, uint16)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<node_id> connect(actor_system&, std::string host, uint16_t port)^ & See~\sref{remoting}. \\
  \hline
  \lstinline^expected<T> remote_actor<T = actor>(actor_system&, string, uint16)^ & See~\sref{remoting}. \\
  \hline
\end{tabular}
\end{center}

\subsection{Transport Protocols \experimental}
\label{transport-protocols}

CAF communication uses TCP per default and thus the functions shown in the
middleman API above are related to TCP. CAF also offers encrypted communication
between nodes via the OpenSSL module \sref{free-remoting-functions}
